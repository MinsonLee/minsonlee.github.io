---
layout: post
title: "14.Git提交历史那些事儿"
date: 2018-09-19
tag: Git
---

## 背景
前面已经记录了git从克隆/创建仓库-->提交至远程仓库的过程！该篇文章会记录如何`查看提交历史`、`重写提交历史`

## 查看提交历史
[博客园-张贺-git log](https://www.cnblogs.com/gbyukg/archive/2011/12/12/2285419.html)

## 重写提交历史
> `重写提交历史`意味着你可以:修改你以往的提交记录、删除或对提交记录进行重新排序,这对于保持分支提交记录的简洁有效有很大的作用！

**重写提交历史的铁则:`只`针对你`本地的提价记录`或`个人分支上的提交的记录`进行重写,否则会造成很严重的后果!**
>原则上重写历史只能是针对本地的提交记录,因为不管你如何的更改本地提交记录,并不会对该远程分支上的其他用户造成影响；但是如果你100%确定该分支只有你自己用,那么该远程分支和你本地是没有区别的,只是你在这种情况下进行了提交历史重写后,需要执行极其不建议的`git push -f`进行强行覆盖远程提交历史记录!

### 重写最后一次提交信息
```sh
$ git commit --am -m "new message"
```

![git commit --am](/images/article/git/git-commit-am.gif)

### 批量重写提交历史
曾在[10.Git操作-分支合并](https://minsonlee.github.io/2018/09/10.git-merge/)一文中的`“变基”合并`中提到过`rebase`的作用：`将当前分支以补丁的方式在指定分支上重演合并`！
**如果在这个演合的过程中,我们能够控制这些演合后的节点的`顺序`、`是否保留该节点`、`是否继续沿用该节点提交信息`**,那么我们就可以达到批量重写历史的目的了!

以下是`git rebase`中`-i`选项的解释，似乎恰好符合我们的目的:
```sh
# -i, --interactive  让用户编辑可提交的rebase列表
-i, --interactive  let the user edit the list of commits to rebase

```


**用法如下:**

```sh
$ git rebase -i commitId [<remote/branch>也是代表一个特殊的commitID]
```

**假设当前分支如下:**

![git rebase situation](/images/article/git/git-rebase-now.png)

我们需要将`fast分支`上的提交重写为3个提交点,合并到master分支上,并进行提交!

1. 将`fast分支`上的提交重写为3个提交点

![git rebase -i](/images/article/git/git-rebase-i-commit.gif)

- `q` 直接使用该提交节点
- `e` 编辑使用该提交节点
- `s` 压缩合并使用提交节点

2. 将重写后的fast分支合并到master分支上
- 使用:`git merge branch` -- 会产生一个额外节点
- 使用:`git rebase master`然后`git merge branch` -- 采用变基合并,提交简洁,但分支信息不明确
- 采用:`git cherry-pick commit`多次采摘提交点进行提交 -- 既保留了原有分支信息,又将其集成到了当前分支,但该种方式可以通过提交时间分清提交节点到底来源于哪个分支,但是麻烦